import{_ as r,o as t,e as o,i,j as s,v as n,q as u,s as c,H as d,E as l}from"./chunks/framework.CXoXy2UI.js";const k=JSON.parse('{"title":"vue2源码阅读2--响应式原理","description":"","frontmatter":{"title":"vue2源码阅读2--响应式原理","class":"vue","date":"2021-11-09"},"headers":[],"relativePath":"posts/2021-vue-vue2源码阅读2响应式原理.md","filePath":"posts/2021-vue-vue2源码阅读2响应式原理.md"}'),p={name:"posts/2021-vue-vue2源码阅读2响应式原理.md"};function m(h,e,v,f,w,b){const a=u("ClientOnly");return t(),o("div",null,[e[1]||(e[1]=i("pre",{class:"mermaid-container",style:{visibility:"hidden"}},`graph TD
A[src/platforms/web/entry-runtime.js] -->|export default Vue \\n \\n Vue来自 ./runtime/index| B(./runtime/index)
B --> C(定义了Vue.prototype.$mount方法, 该方法里面具体调用了mountComponent)
C --> D(此处的Vue来自core/index)
D -->|core/index中的Vue来自./instance/index| E(./instance/index中定义了Vue函数)
E --> Vue(new Vue, Vue构造函数里面执行了this._init)
Vue --> init(initMixin中定义了Vue.prototype._init)
init --> initState(initState)
initState --> initProps(initProps)
initProps --> initMethods(initMethods)
initMethods --> initData(initData)
initData --> |调用getData| getData("data.call(vm, vm)获取data函数中返回的对象")
getData --> observe(observe)
observe --> Observer("new Observer(value)")
Observer --> |constructor| ObserverConstructor("this.dep = new Dep()")
ObserverConstructor --> walk(walk)
walk --> |给对象的每个字段设置响应式| defineReactive(defineReactive)
defineReactive --> F("let childOb = !shallow && observe(val)递归调用observe继续给子对象设置响应式")
F --> observe
F --> G(Object.defineProperty)
G --> get(劫持get)
get --> |"每个字段都有实例化相应的dep \\n \\n 它与组件在mountComponent里实例化的Watcher \\n \\n 通过dep.depend(), 相互持有依赖 \\n \\n \\n \\n dep持有watcher就能在修改数据的时候更新页面 \\n \\n 为什么watcher还要持有dep？\\n \\n \\n \\n 因为watcher只有维护新旧dep，才能在收集依赖后 \\n \\n cleanupDeps \\n \\n 避免组件中未使用的数据修改时，导致组件更新"| H(return value)
G --> set(劫持set)
set --> notify(dep.notify)
notify --> |dep依赖的每个Watcher都执行update| update("subs[i].update()")
update --> queueWatcher(queueWatcher)
queueWatcher --> nextTick("nextTick(flushSchedulerQueue)")
nextTick --> pms("p.then(flushCallbacks)通过promise.then, 在微任务中执行flushCallbacks")
pms --> |flushCallbacks中调用| flushSchedulerQueue(flushSchedulerQueue)
flushSchedulerQueue --> watcherBefore(watcher.before)
watcherBefore --> beforeUpdate1(mountComponent中, 实例化Watcher时, 定义了before)
beforeUpdate1 --> beforeUpdate2(调用钩子函数beforeUpdate)
beforeUpdate2 --> |watcher.before执行完后| watcherRun("watcher.run()")
watcherRun --> |调用watcher的get| watcherGet("this.get()")
watcherGet --> |getter来自mountComponent实例化Watcher时| watcherGet2("this.getter.call(vm, vm)")
watcherGet2 --> vmUpdate("vm._update(vnode, hydrating)完成新旧虚拟dom的比对和更新")
vmUpdate --> watcherRun
watcherRun --> callUpdatedHooks(callUpdatedHooks)
callUpdatedHooks --> callHook("callHook(vm,'updated')") 
callHook --> updated(调用钩子函数updated)
updated --> End[完成响应式更新]
`,-1)),s(a,null,{default:n(()=>[(t(),c(l("script"),null,{default:n(()=>e[0]||(e[0]=[d(' (() => { const timer = setInterval(async () => { if (window.mermaid) { await window.mermaid.run({ querySelector: ".mermaid-container" }); const container = document.querySelector(".mermaid-container"); if (container) { container.style.visibility = "visible"; } clearInterval(timer); } }, 500); })(); ')])),_:1}))]),_:1})])}const y=r(p,[["render",m]]);export{k as __pageData,y as default};
