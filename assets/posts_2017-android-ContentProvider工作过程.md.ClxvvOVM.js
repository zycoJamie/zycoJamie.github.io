import{_ as t,o,e as n,G as r}from"./chunks/framework.CXoXy2UI.js";const a="/img/1.png",u=JSON.parse('{"title":"ContentProvider工作过程","description":"","frontmatter":{"title":"ContentProvider工作过程","class":"android","date":"2017-02-26"},"headers":[],"relativePath":"posts/2017-android-ContentProvider工作过程.md","filePath":"posts/2017-android-ContentProvider工作过程.md"}'),i={name:"posts/2017-android-ContentProvider工作过程.md"};function d(l,e,s,c,p,C){return o(),n("div",null,e[0]||(e[0]=[r('<p>ContentProvider所在进程启动时，ContentProvider的onCreate方法先于Application的onCreate方法执行</p><h3 id="启动过程" tabindex="-1">启动过程 <a class="header-anchor" href="#启动过程" aria-label="Permalink to &quot;启动过程&quot;">​</a></h3><p><img src="'+a+'" alt="8f5158bbb270c56ef9ebb13a0fadeae9"></p><h3 id="从getcontentresolver-query说起" tabindex="-1">从getContentResolver().query说起 <a class="header-anchor" href="#从getcontentresolver-query说起" aria-label="Permalink to &quot;从getContentResolver().query说起&quot;">​</a></h3><blockquote><p>通过ActivityThread.acqureProvider先检查内存中是否存在目标ContentProvider，存在则直接返回，不存在就RPC通信，让AMS启动目标ContentProvider进程</p></blockquote><h3 id="handlebindapplication" tabindex="-1">handleBindApplication <a class="header-anchor" href="#handlebindapplication" aria-label="Permalink to &quot;handleBindApplication&quot;">​</a></h3><blockquote><p>该方法最终会循环创建目标ContentProvider，并调用相应ContentProvider的onCreate方法和借助Instrumentation.callApplicationOnCreate方法调用Application.onCreate方法，然后将创建的目标ContentProvider存储在AMS中，当外部调用getContentResolver().query会获取到 IContentProvider这Binder类的实例，最后通过RPC调用ContentProvider的query实现</p></blockquote>',7)]))}const P=t(i,[["render",d]]);export{u as __pageData,P as default};
